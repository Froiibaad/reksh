
//----------------------------------------------------
// The following code was generated by CUP v0.10k
// Thu Mar 15 17:47:25 CET 2007
//----------------------------------------------------

package simulator.assembler;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;

/** CUP v0.10k generated parser.
  * @version Thu Mar 15 17:47:25 CET 2007
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Production table. */
  protected static final short _production_table[][] =
    unpackFromStrings(new String[] {
    "\000\035\000\002\003\003\000\002\002\004\000\002\004" +
    "\005\000\002\004\004\000\002\004\004\000\002\004\003" +
    "\000\002\005\004\000\002\005\003\000\002\006\004\000" +
    "\002\006\005\000\002\007\004\000\002\007\003\000\002" +
    "\010\005\000\002\010\003\000\002\011\003\000\002\012" +
    "\003\000\002\016\002\000\002\012\005\000\002\012\004" +
    "\000\002\012\005\000\002\013\003\000\002\013\003\000" +
    "\002\013\005\000\002\013\005\000\002\013\004\000\002" +
    "\015\003\000\002\015\003\000\002\014\005\000\002\014" +
    "\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table =
    unpackFromStrings(new String[] {
    "\000\060\000\022\012\015\013\021\014\024\015\023\016" +
    "\006\017\017\020\016\021\005\001\002\000\016\014\ufff6" +
    "\015\ufff6\016\ufff6\017\ufff6\020\ufff6\021\ufff6\001\002\000" +
    "\004\004\ufff3\001\002\000\004\021\062\001\002\000\004" +
    "\002\061\001\002\000\004\002\ufffc\001\002\000\004\002" +
    "\001\001\002\000\016\014\024\015\023\016\006\017\017" +
    "\020\016\021\005\001\002\000\016\014\ufff4\015\ufff4\016" +
    "\ufff4\017\ufff4\020\ufff4\021\ufff4\001\002\000\022\012\015" +
    "\013\021\014\024\015\023\016\006\017\017\020\016\021" +
    "\005\001\002\000\004\023\052\001\002\000\004\002\uffe5" +
    "\001\002\000\004\011\050\001\002\000\022\012\ufffa\013" +
    "\ufffa\014\ufffa\015\ufffa\016\ufffa\017\ufffa\020\ufffa\021\ufffa" +
    "\001\002\000\004\021\046\001\002\000\004\004\043\001" +
    "\002\000\016\005\ufff1\007\ufff1\011\ufff1\021\ufff1\022\ufff1" +
    "\023\ufff1\001\002\000\016\014\ufff2\015\ufff2\016\ufff2\017" +
    "\ufff2\020\ufff2\021\ufff2\001\002\000\016\005\026\007\030" +
    "\011\033\021\035\022\032\023\034\001\002\000\006\021" +
    "\035\023\034\001\002\000\016\014\ufff0\015\ufff0\016\ufff0" +
    "\017\ufff0\020\ufff0\021\ufff0\001\002\000\006\021\035\023" +
    "\034\001\002\000\016\014\uffec\015\uffec\016\uffec\017\uffec" +
    "\020\uffec\021\uffec\001\002\000\016\014\uffed\015\uffed\016" +
    "\uffed\017\uffed\020\uffed\021\uffed\001\002\000\006\021\035" +
    "\023\034\001\002\000\022\006\uffe8\010\uffe8\014\uffe8\015" +
    "\uffe8\016\uffe8\017\uffe8\020\uffe8\021\uffe8\001\002\000\022" +
    "\006\uffe7\010\uffe7\014\uffe7\015\uffe7\016\uffe7\017\uffe7\020" +
    "\uffe7\021\uffe7\001\002\000\016\014\uffe9\015\uffe9\016\uffe9" +
    "\017\uffe9\020\uffe9\021\uffe9\001\002\000\004\010\040\001" +
    "\002\000\016\014\uffea\015\uffea\016\uffea\017\uffea\020\uffea" +
    "\021\uffea\001\002\000\004\006\042\001\002\000\016\014" +
    "\uffeb\015\uffeb\016\uffeb\017\uffeb\020\uffeb\021\uffeb\001\002" +
    "\000\014\014\024\015\023\016\006\017\017\020\045\001" +
    "\002\000\016\014\ufff5\015\ufff5\016\ufff5\017\ufff5\020\ufff5" +
    "\021\ufff5\001\002\000\004\002\uffe6\001\002\000\004\023" +
    "\047\001\002\000\022\012\ufff8\013\ufff8\014\ufff8\015\ufff8" +
    "\016\ufff8\017\ufff8\020\ufff8\021\ufff8\001\002\000\006\021" +
    "\035\023\034\001\002\000\016\014\uffee\015\uffee\016\uffee" +
    "\017\uffee\020\uffee\021\uffee\001\002\000\022\012\ufff9\013" +
    "\ufff9\014\ufff9\015\ufff9\016\ufff9\017\ufff9\020\ufff9\021\ufff9" +
    "\001\002\000\004\002\ufffe\001\002\000\016\014\024\015" +
    "\023\016\006\017\017\020\016\021\005\001\002\000\022" +
    "\012\ufffb\013\ufffb\014\ufffb\015\ufffb\016\ufffb\017\ufffb\020" +
    "\ufffb\021\ufffb\001\002\000\016\014\ufff7\015\ufff7\016\ufff7" +
    "\017\ufff7\020\ufff7\021\ufff7\001\002\000\004\002\uffff\001" +
    "\002\000\004\002\ufffd\001\002\000\004\002\000\001\002" +
    "\000\016\014\uffef\015\uffef\016\uffef\017\uffef\020\uffef\021" +
    "\uffef\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table =
    unpackFromStrings(new String[] {
    "\000\060\000\024\003\006\004\010\005\013\006\017\007" +
    "\011\010\003\011\021\012\012\014\007\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\012\010\055" +
    "\011\021\012\012\014\057\001\001\000\002\001\001\000" +
    "\016\006\054\007\053\010\003\011\021\012\012\014\052" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\016\024\001\001\000\002\001\001\000\006\013" +
    "\026\015\030\001\001\000\004\015\040\001\001\000\002" +
    "\001\001\000\004\015\036\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\015\035\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\012\043\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\015\050\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\012\010\055\011\021\012\012\014\056\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}




public Symbol parse(String filename) {
  FileReader fr = null;
  try {
    fr = new FileReader(filename);
    this.filename = filename;
    setScanner(new Tokenizer(fr));
    return parse();
  } catch (Exception e) {
    System.err.println(e);
  } finally {
    try {fr.close();}
    catch(Exception e) {}
  }
  return null;
}

public Symbol scan() throws Exception {
  Symbol s = getScanner().next_token();
  if (s.sym == sym.INVALID) {
    report_fatal_error("Linija " + getLine() + ": " + "Lexical error: " + s.value, null);
    return null;
  } else {
    //System.out.println("TOKEN: " + s.toString());
    return s;
  }
}

// Ime fajla koji se parsira
private String filename = null;
public String getFileName() {return filename;}

// Ako postoji greska pri parsiranju ne vrsi se ispis
private boolean error = false;
public boolean error() {return error;}

public void report_error(String message, Object info) {
  System.err.println(message);
  error = true;
}

public void report_fatal_error(String message, Object info) throws Exception {
  done_parsing();
  report_error(message, info);
  throw new Exception("Fatal error");
}

public void syntax_error(Symbol cur_token) {
  report_error("Linija " + getLine() + ": " + "Syntax error:", cur_token);
}

public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
  report_fatal_error("Linija " + getLine() + ": " + "Fatal syntax error:", cur_token);
}

public int getLine() {
  return ((Tokenizer)getScanner()).getLine() + 1;    // +1 jer skener broji linije od nulte;
}


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {


  SymbolTable table = new SymbolTable();

  // Ako postaji vise ORG direktiva to je greska
  boolean orgDefined = false;

  // Podrazumevana pocetna adresa je 100h
  short startAddress = 0x100;

  // Brojac lokacija (location counter) za odredjivanje adresa - one su 16b (short)
  short lc = 0;

  // Niz bajtova koji predstavlja apsolutizovani masinski kod
  ArrayList<Byte> code = new ArrayList<Byte>();

  // Cuva tekucu jednoadresnu instrukciju
  String ins_A1 = null;

  // Generise masinski kod za bezadresne instrukcije
  public byte GenCodeA0(String ins) {
    // bezadresne
    if      (ins.equals("RTS"))  return 0x00;
    else if (ins.equals("RTI"))  return 0x01;
    else if (ins.equals("INTE")) return 0x02;
    else if (ins.equals("INTD")) return 0x03;
    else if (ins.equals("TRPE")) return 0x04;
    else if (ins.equals("TRPD")) return 0x05;
    else if (ins.equals("HALT")) return 0x06;
    // skokovi
    else if (ins.equals("JZ"))   return 0x40;
    else if (ins.equals("JMP"))  return 0x41;
    else if (ins.equals("JSR"))  return 0x42;
    else if (ins.equals("INT"))  return 0x43;
    else                         return -1;
  }

  // Generise masinski kod za jednoadresne instrukcije
  public byte GenCodeA1(String ins, int adrMode) {
    if      (ins.equals("LOAD"))  return (byte)(0x80 | adrMode);
    else if (ins.equals("STORE")) return (byte)(0x88 | adrMode);
    else if (ins.equals("ADD"))   return (byte)(0x90 | adrMode);
    else if (ins.equals("XOR"))   return (byte)(0x98 | adrMode);
    else if (ins.equals("LSR"))   return (byte)(0xA0 | adrMode);
    else                          return -1;
  }

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // halt ::= INS_HALT
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA0(ins))); lc++;
              CUP$Parser$result = new java_cup.runtime.Symbol(10/*halt*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // halt ::= label COLON INS_HALT
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA0(ins))); lc++;
              CUP$Parser$result = new java_cup.runtime.Symbol(10/*halt*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // operand ::= IDENT
            {
              Integer RESULT = null;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 Node n = table.find(id);
                 if (n == null) {
                   parser.report_error("Linija " + (parser.getLine()-1) + ": Nije definisan identifikator " + id, null);
                   RESULT = Integer.valueOf(-1);
                 } else if (n.kind == Node.Label) {
                   parser.report_error("Linija " + (parser.getLine()-1) + ": Operand ne moze da bude labela", null);
                   RESULT = Integer.valueOf(-1);
                 } else {
                   RESULT = Integer.valueOf(n.value);
                 }

              CUP$Parser$result = new java_cup.runtime.Symbol(11/*operand*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // operand ::= NUMBER
            {
              Integer RESULT = null;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 RESULT = num;
              CUP$Parser$result = new java_cup.runtime.Symbol(11/*operand*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // addressing_mode ::= HASH operand
            {
              Object RESULT = null;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x07))); lc++;
                         if (op.intValue() >= -128 && op.intValue() <= 255) {
                           code.add(op.byteValue()); lc++;
                         } else {
                           code.add(op.byteValue()); lc++;
                           parser.report_error("Linija " + (parser.getLine()-1) + ": Operand za neposredno adresiranje mora biti 8b oznacen ili neoznacen broj", null);
                         }

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*addressing_mode*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // addressing_mode ::= LBRACE operand RBRACE
            {
              Object RESULT = null;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x06))); lc++;
                         if (op.intValue() >= 0 && op.intValue() <= 65535) {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                         } else {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                           parser.report_error("Linija " + (parser.getLine()-1) + ": Operand za relativno adresiranje mora biti 16b neoznacen broj", null);
                         }

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*addressing_mode*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // addressing_mode ::= LSQUARE operand RSQUARE
            {
              Object RESULT = null;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		 code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x05))); lc++;
                         if (op.intValue() >= 0 && op.intValue() <= 65535) {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                         } else {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                           parser.report_error("Linija " + (parser.getLine()-1) + ": Operand za mem. indirektno adresiranje mora biti 16b neoznacen broj", null);
                         }

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*addressing_mode*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // addressing_mode ::= operand
            {
              Object RESULT = null;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x04))); lc++;
                         if (op.intValue() >= 0 && op.intValue() <= 65535) {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                         } else {
                           code.add(Integer.valueOf(op.intValue() >> 8).byteValue()); lc++;
                           code.add(op.byteValue()); lc++;
                           parser.report_error("Linija " + (parser.getLine()-1) + ": Operand za mem. direktno adresiranje mora biti 16b neoznacen broj", null);
                         }

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*addressing_mode*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // addressing_mode ::= REG
            {
              Object RESULT = null;
		Integer r = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 switch(r.intValue()) {
                           case 0: code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x00))); lc++; break;
                           case 1: code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x01))); lc++; break;
                           case 2: code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x02))); lc++; break;
                           case 3: code.add(Byte.valueOf(GenCodeA1(ins_A1, 0x03))); lc++; break;
                         }

              CUP$Parser$result = new java_cup.runtime.Symbol(9/*addressing_mode*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // instruction_type ::= INS_INT HASH operand
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		Integer op = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA0(ins))); lc++;
                          if (op.intValue() >= 0 && op.intValue() <= 255) {
                            code.add(op.byteValue()); lc++;
                          } else {
                            code.add(op.byteValue()); lc++;
                            parser.report_error("Linija " + (parser.getLine()-1) + ": Operand instrukcije INT mora biti 8b neoznacen broj", null);
                          }

              CUP$Parser$result = new java_cup.runtime.Symbol(8/*instruction_type*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // instruction_type ::= INS_JUMP IDENT
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA0(ins))); lc++;
                          Node n = table.find(id);
                          if (n == null) {
                            n = table.insert(Node.Label, id);
                            n.addAddress(lc);
                            code.add(Byte.valueOf((byte)0)); lc++;
                            code.add(Byte.valueOf((byte)0)); lc++;
                          } else if (n.kind == Node.Const) {
                            parser.report_error("Linija " + (parser.getLine()-1) + ": Operand za instrukcije skoka mora biti labela", null);
                            code.add(Byte.valueOf((byte)0)); lc++;
                            code.add(Byte.valueOf((byte)0)); lc++;
                          } else if (n.defined) {
                            code.add(Integer.valueOf(n.value >> 8).byteValue()); lc++;
                            code.add(Short.valueOf(n.value).byteValue()); lc++;
                          } else {
                            n.addAddress(lc);
                            code.add(Byte.valueOf((byte)0)); lc++;
                            code.add(Byte.valueOf((byte)0)); lc++;
                          }

              CUP$Parser$result = new java_cup.runtime.Symbol(8/*instruction_type*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // instruction_type ::= INS_A1 NT$0 addressing_mode
            {
              Object RESULT = null;
              // propagate RESULT from NT$0
              if ( ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value != null )
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;

              CUP$Parser$result = new java_cup.runtime.Symbol(8/*instruction_type*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // NT$0 ::=
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
 ins_A1 = ins;
              CUP$Parser$result = new java_cup.runtime.Symbol(12/*NT$0*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // instruction_type ::= INS_A0
            {
              Object RESULT = null;
		String ins = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 code.add(Byte.valueOf(GenCodeA0(ins))); lc++;
              CUP$Parser$result = new java_cup.runtime.Symbol(8/*instruction_type*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // label ::= IDENT
            {
              Object RESULT = null;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 Node n = table.find(id);
             if (n == null) {
               table.insert(Node.Label, id, lc);
             } else if (n.defined) {
               parser.report_error("Linija " + (parser.getLine()) + ": Vec postoji labela sa imenom " + id, null);
             } else {
               Address adr = n.adr;
               while (adr != null) {
                 code.set(adr.val-startAddress, Integer.valueOf(lc >> 8).byteValue());
                 code.set(adr.val-startAddress+1, Short.valueOf(lc).byteValue());
                 adr = adr.next;
               }
               n.adr = null;
               n.value = lc;
               n.defined = true;
             }

              CUP$Parser$result = new java_cup.runtime.Symbol(7/*label*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // instruction ::= instruction_type
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(6/*instruction*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // instruction ::= label COLON instruction_type
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(6/*instruction*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // instruction_list ::= instruction
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(5/*instruction_list*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // instruction_list ::= instruction_list instruction
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(5/*instruction_list*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // directive ::= DEF IDENT NUMBER
            {
              Object RESULT = null;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 table.insert(Node.Const, id, num.shortValue());
              CUP$Parser$result = new java_cup.runtime.Symbol(4/*directive*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // directive ::= ORG NUMBER
            {
              Object RESULT = null;
		Integer num = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0)).value;
		 if (orgDefined) {
                     parser.report_error("Linija " + (parser.getLine()-1) + ": Visestruke ORG direktive", null);
                   } else {
                     startAddress = num.shortValue();
                     orgDefined = true;
                     lc = startAddress;
                   }

              CUP$Parser$result = new java_cup.runtime.Symbol(4/*directive*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // directive_list ::= directive
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(3/*directive_list*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // directive_list ::= directive_list directive
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(3/*directive_list*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // program ::= halt
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(2/*program*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // program ::= instruction_list halt
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(2/*program*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // program ::= directive_list halt
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(2/*program*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= directive_list instruction_list halt
            {
              Object RESULT = null;

              CUP$Parser$result = new java_cup.runtime.Symbol(2/*program*/, RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= asm EOF
            {
              Object RESULT = null;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = new java_cup.runtime.Symbol(0/*$START*/, RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // asm ::= program
            {
              Object RESULT = null;
		 System.out.println("\nJipiiiiiiiii!");
           //table.dump();
           // (Ovo bi radio linker) Provera tabele simbola, ako postoje undefined labele to je greska
           Node n = null;
           while ((n = table.remove()) != null) {
             if (!n.defined) parser.report_error("Ne postoji labela sa imenom " + n.name, null);
           }
           // Kreiranje fajla sa masinskim kodom ako je parsiranje uspesno
           if (!parser.error()) {
             FileWriter fw = null;
             try {
               String filename = parser.getFileName().substring(0, parser.getFileName().lastIndexOf(".")) + ".mc";
               fw = new FileWriter(filename);
               fw.write(Integer.toHexString(startAddress) + "\r\n");
               while (!code.isEmpty()) {
                 Byte b = code.remove(0);
                 String hexstr = Integer.toHexString(b);
    	         if (hexstr.length() == 1) hexstr = "0" + hexstr;
                 fw.write(hexstr.substring(hexstr.length()-2).toUpperCase() + " ");
               }
               System.out.println("Output file is: " + filename);
             } catch (IOException ioe) {
               System.err.println(ioe);
             } finally {
               try {fw.close();}
               catch (IOException ioe) {}
             }
           }

              CUP$Parser$result = new java_cup.runtime.Symbol(1/*asm*/, RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

